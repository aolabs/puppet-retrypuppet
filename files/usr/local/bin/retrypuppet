#!/usr/bin/env python

from __future__ import print_function
from time import sleep
from subprocess import Popen, PIPE, STDOUT
import sys

# Any arguments are passed directly to puppet.
args = sys.argv
args.pop(0)



# Function to run puppet, will return False if puppet was locked (already
# running).  Stdout and stderr are passed through to the console.
def run():

  # Run puppet inside stdbuf to attempt to eliminate any buffering.
  with Popen( [ 'stdbuf', '-oL', '-eL', 'puppet' ] + sys.argv, stdout=PIPE, stderr=STDOUT ) as p:

    locked=False
    line_num=0

    # Loop through the lines of input until puppet exits.
    for line in p.stdout:

      # Count lines read from the puppet agent.
      line_num += line_num

      # Check if the first line of output indicates puppet already running (the in progress message appears to
      # always be on the first line, so we don't waste time checking every line of the run - short-circuit logic).
      if line_num == 1 and ( 'run of puppet configuration client already in progress' in line.lower().decode() ):
        locked = True

      # Pass the output of puppet through to the console if the run was not locked (if locked,
      # we still loop to drain the input buffer and avoid any orphan child processes).
      if not locked:
        sys.stdout.write( line.decode() )
        sys.stdout.flush()

  # If puppet output indicated that a run was already in progress, then return False.
  if locked:
    return False
  else:
    return True



# How many attemps should be made, how long should we wait in seconds.
retries=10
delay=30

# Retry until run returns true or we run out of retries.
while not run() and retries:
  print( 'Run already in progress, will retry in {} seconds. {} attempts remain...'.format( delay, retries ) )
  sleep( delay )
  retries -= 1
  if not retries:
    print( 'No attempts remain...will exit.')
